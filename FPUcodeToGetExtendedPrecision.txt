fld st(0),st(0) // Duplicate st0 into st1
fld st(0),st(0) // Now we have the same value in st0, st1, and st2
frndint // Round st0 to the nearest integer (up or down)
fcomi st(0),st(1) // Compare st0 with st1
jbe @trunc // If it's less than or equal, jump
fld1 // Load 1 into st0 -> if greater, subtract 1 to get number truncated
fsubp st(1),st(0) // Subtract st1 from st0
fld st(0),st(0) // Now the result is in st0 and st1
@trunc // trunc integer
fsubp st(2),st(0) // Subtract st2 from st0 -> subtract the number with the truncated integer, to get de fraccional part
fxch st(0),st(1) // Swap the contents of st0 and st1
mov ax,64 // Load 64 (100 in decimal) into ax
mov word ptr ss:[ebp-1A],ax // Put 100 in ebp-1A
fimul st(0),word ptr ss:[ebp-1A] // Multiply st0 by 100 -> Now we have the decimal part with two decimal digits (more aren't real)
fbstp tword ptr ss:[ebp-18],st(0) // Save the fractional part (2 BCD bytes) in ebp-18
fbstp tword ptr ss:[ebp-17],st(0) // Save the integer part (8 BCD bytes) in ebp-17
fwait // One wait cycle
fninit // Reset the FPU